
#   0000000   0000000   00000000  00000000  00000000  00000000
#  000       000   000  000       000       000       000
#  000       000   000  000000    000000    0000000   0000000
#  000       000   000  000       000       000       000
#   0000000   0000000   000       000       00000000  00000000

\w+                                   text
[^\w\s]+                              syntax

[\<\>\+\-\=\/\*]                      math

@                                     this
\$                                    this
\?                                    cond
!=                                    math
->                                    function.marker
=>                                    function.marker.bound

# punctuation

[\,\;]                                punctuation

# braces

[({\[]                                bracket.open
[)}\]]                                bracket.close

# require

(\w+|\{[^\}]+\})\s*=\s*(require)\s+
    require.variable
    keyword.require

# globals

(\bconsole\.|\bprocess\.|\bglobal\.|\bmodule\.|\bexports\.|\bpath\.|\bfs\.|\bos\.)  . module

# special

\blog\b                               function
\berr\b                               function.call
\berror\b                             function.call

# bool

true                                  bool.true
false                                 bool.false

# null

null|undefined                        keyword.null
return                                keyword.return

# .property

(\s*\w+)\.                            owner
(\.\s*\w+)                            property

# functions

(\w+)\s*[=]\s*\([^\)]*\)\s*[-=]>    . function
(\w+)\s*[=]\s*[-=]>                 . function
(@?\w+)\s*[:]\s*\([^\)]*\)\s*[-=]>  . method
(@?\w+)\s*[:]\s*[-=]>               . method
# (\()[^\(\)]*(\)\s*)[-=]>            . function.bracket . function.bracket

(@?[a-zA-Z]\w*)(?!\s+or|\s+i[fs]|\s+and|\s+then)(?=\(|\s+[@\w\d\"\'\(\[\{])    function.call
(_)(?:$|\.|\s)                        bool.false

# class

(class|extends)\s+(\w+)             . class.keyword . class.object

new\s+(\w+)                           class.callee
@[a-zA-Z]\w*                          class.member

(?:[^\.])([\.])(?:[^\.])            . marker

# range

(\[).*[^\.](\.\.\.?)[^\.].*(\])     . range.bracket . range . range.bracket

# dictionary key

(\S+)\s*(:)                         . dictionary.key . dictionary.key.marker

# exists?

\S+(\?)                               exists

# keywords

(^|\s)(if|else|then|for|of|in|is|while|do|unless|not|or|and|try|catch|return|require|break|continue|new|switch|when|super|extends)(\s|$)
    none
    keyword
    none

__dirname|__filename                  keyword

#number

(?:^|[^\.\"\'\w]|\.\.\.?)([\+\-]?)(\d+\.\d+)(?:$|[^\.\"\'\w]|\.\.\.?)
    number.float.sign
    number.float

(?:^|[^\.\"\'\w]|\.\.\.?)([\+\-]?)(\d+)(?:$|[^\.\"\'\w]|\.\.\.?)
    number.int.sign
    number.int

(?:^|[^\.\"\'\w]|\.\.\.?)(0x)([\da-f]+)(?:$|[^\.\"\'\w]|\.\.\.?)
    number.int.marker
    number.int

# strings
'                                     string.marker.single
"                                     string.marker.double
\#\{                                  string.interpolation

|###|                                 comment.marker
(?:^|\s+)(#+)([^\{].*|$)            . comment.marker . comment

# salter headers

^\s*(\#)([0\s]+)$                   . comment.marker . comment.header
^(\s*0[0\s]+)$                        comment.header
