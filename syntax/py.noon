
# 00000000   000   000
# 000   000   000 000 
# 00000000     00000  
# 000           000   
# 000           000   

[\<\>\+\-\=\/\*]               math

@                              this
\$                             this
\?                             cond
!=                             math
->                             function.marker
=>                             function.marker.bound

# braces

[\(\)\{\}\[\]]                 bracket

# require

(\w+|\{[^\}]+\})\s*=\s*(require)\s+
    require.variable
    keyword.require 

# class

(class)\s+(\w+)              . class.keyword . class

# globals

(\bsys\.|\btypes\.|\bpath\.|\bos\.|\bjson\.|\bargparse\.)  . module

# special

\blog\b                        function.log
\berr\b                        variable.err
\berror\b                      function.err

# bool

True                           bool.true
False                          bool.false 

# null

None                           keyword.null

# class members

(@\w+)(?=\s*[\?\=\,\+\-\.\<\>\*\/\]\[\)]|\s*$)    class.variable

# .property

(\s*\w+)\.                     owner
\.(\s*\w+)                     property

# functions 

(:\s*)($|#.*$)                 keyword

def\s+(\w+)\s*(\()[^\)]*(\))\s*:    . function . function.bracket . function.bracket

(\w+)(?=\(|\s+[@\w\d\"\'\(\[\{])      function.call

# dictionary key

("\S+"|'\S+')\s*(:)                 . dictionary.key . dictionary.key.marker

# punctuation

[\,\.\;]                       punctuation

# keywords

(?:^|\s)(else:|try:|except:|range|print|pass|of|in|not|or|and|return|import|break|continue|global)(?:\s|$)   keyword 
(?:^|\s)(def|if|elif|for|while|except)\s.*(:)\s*(?:$|#.*$)      . keyword . keyword
    
__name__|__class__  keyword

#number

(?:^|[^\.\"\'\w]|\.\.\.?)([\+\-]?)(\d+\.\d+)(?:$|[^\.\"\'\w]|\.\.\.?)   
    number.float.sign
    number.float

(?:^|[^\.\"\'\w]|\.\.\.?)([\+\-]?)(\d+)(?:$|[^\.\"\'\w]|\.\.\.?)   
    number.int.sign
    number.int
